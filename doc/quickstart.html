<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Quick Start Guide &mdash; Saddle 1.0.0 documentation</title>
    
    <link rel="stylesheet" href="_static/saddle.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Saddle 1.0.0 documentation" href="index.html" />
    <link rel="next" title="User Guide" href="guide.html" />
    <link rel="prev" title="What’s New" href="whatsnew.html" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head>
  <body>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="quick-start-guide">
<h1>Quick Start Guide<a class="headerlink" href="#quick-start-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="intro">
<h2>Intro<a class="headerlink" href="#intro" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s take a quick tour through Saddle to get a sense of the feature set. There
are five major array-backed, specialized data structures:</p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="62%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Class</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Vec</td>
<td>1D vector</td>
</tr>
<tr class="row-odd"><td>Mat</td>
<td>2D matrix</td>
</tr>
<tr class="row-even"><td>Series</td>
<td>1D indexed vector</td>
</tr>
<tr class="row-odd"><td>Frame</td>
<td>2D indexed matrix</td>
</tr>
<tr class="row-even"><td>Index</td>
<td>Hashmap-like</td>
</tr>
</tbody>
</table>
<p>All are designed with immutability in mind, although since they are backed by
arrays and the library tries to be conservative in copying data, you should be
careful not to let the backing arrays escape object construction.</p>
<p>Let&#8217;s look at each one in turn through examples. If you&#8217;ve got the source code
and an SBT launcher, run the following (from the directory where you&#8217;ve got
Saddle checked out):</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">$</span> <span class="n">sbt</span> <span class="n">console</span>
</pre></div>
</div>
<p>If you&#8217;ve only got the Saddle jar in your classpath, the relevant import is:</p>
<div class="code scala highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">org.saddle._</span>
</pre></div>
</div>
<p>(This should bring in all the implicits you need for the examples below.)</p>
<p>Note: by default, toString will print up to some number of data entries. If you
would like to see more data, simply call the print() method on the relevant
object with a larger number.</p>
</div>
<div class="section" id="vec">
<h2>Vec<a class="headerlink" href="#vec" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s walk through some examples in an sbt console session.</p>
<p>First, a few ways to create Vec instances:</p>
<div class="code scala highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">)</span>               <span class="c1">// pass a sequence directly</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="mi">3</span> <span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>           <span class="c1">// pass a sequence indirectly</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>          <span class="c1">// wrap an array into a Vec</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">))</span>            <span class="c1">// not usually what you want!</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="nc">Seq</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="k">:</span> <span class="k">_</span><span class="kt">*</span><span class="o">)</span>       <span class="c1">// yes, usually what you want!</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span>          <span class="c1">// create an empty Vec</span>
</pre></div>
</div>
<p>There are also a few special factories:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">ones</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">zeros</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</pre></div>
</div>
<p>Sometimes random Vec instances are useful. There are a few ways to accomplish
this:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">rand</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>             <span class="c1">// 1000 random doubles, -1.0 to 1.0 (excluding 0)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randp</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>            <span class="c1">// a thousand random positive doubles</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randi</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span>            <span class="c1">// a thousand random ints</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randpi</span><span class="o">(</span><span class="mi">1000</span><span class="o">)</span> <span class="o">%</span> <span class="mi">10</span>      <span class="c1">// a thousand random positive ints, from 1 to 9</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randn</span><span class="o">(</span><span class="mi">100</span><span class="o">)</span>             <span class="c1">// 100 normally distributed observations</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">vec</span><span class="o">.</span><span class="n">randn2</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">15</span><span class="o">)</span>     <span class="c1">// 100 obs normally distributed with mean 2 and stdev 15</span>
</pre></div>
</div>
<p>Let&#8217;s take a quick look at some operations you can do on Vec instances. All the
major arithmetic operations are supported between two Vec instances and between
a Vec and a scalar.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="o">*</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="n">dot</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="n">outer</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="o">**</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="o">&amp;</span> <span class="mh">0x1</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span> <span class="o">+</span> <span class="mi">2</span>             <span class="c1">// Note: 2 must be on right hand side (it&#39;s Vec.`+`)</span>
</pre></div>
</div>
<p>You can also slice out data from a Vec in various ways:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">rand</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">at</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>                        <span class="c1">// wrapped in Scalar, in case of NA</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">org.saddle.scalar.Scalar</span><span class="o">[</span><span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="o">-</span><span class="mf">0.19816001024987906</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">raw</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>                       <span class="c1">// raw access to primitive type; be careful!</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.19816001024987906</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">8</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">(</span><span class="mi">2</span> <span class="o">-&gt;</span> <span class="mi">4</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">(*</span> <span class="o">-&gt;</span> <span class="mi">3</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">(</span><span class="mi">8</span> <span class="o">-&gt;</span> <span class="o">*</span> <span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">slice</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">8</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>
</pre></div>
</div>
<p>There are statistical functions available:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">sum</span>
<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">prod</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">6</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">mean</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">median</span>
<span class="n">res3</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">2.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">max</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Some</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">stdev</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">variance</span>
<span class="n">res6</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">skew</span>
<span class="n">res7</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">0.0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">kurt</span>
<span class="n">res8</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="nc">NaN</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">geomean</span>
<span class="n">res9</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.8171205928321394</span>

<span class="c1">// etc ...</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">count</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">countif</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">logsum</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">argmin</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">percentile</span><span class="o">(</span><span class="mf">0.3</span><span class="o">,</span> <span class="n">method</span><span class="k">=</span><span class="nc">PctMethod</span><span class="o">.</span><span class="nc">NIST</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">demeaned</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">rank</span><span class="o">(</span><span class="n">tie</span><span class="k">=</span><span class="nc">RankTie</span><span class="o">.</span><span class="nc">Avg</span><span class="o">,</span> <span class="n">ascending</span><span class="k">=</span><span class="kc">true</span><span class="o">)</span>
</pre></div>
</div>
<p>As well as a few specially-implemented rolling statistical functions:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">rand</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">rollingSum</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>            <span class="c1">// with window size = 5</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">rollingMean</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>           <span class="c1">// etc.</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">rollingMedian</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">rollingCount</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</pre></div>
</div>
<p>In fact, you can do any calculation you&#8217;d like over the rolling window:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">rolling</span><span class="o">(</span><span class="mi">5</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">stdev</span><span class="o">)</span>      <span class="c1">// window size = 5, take stdev of vector input</span>
</pre></div>
</div>
<p>Let&#8217;s take a quick look at some more advanced functionality:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">rand</span><span class="o">(</span><span class="mi">10</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">)</span>          <span class="c1">// these three commands are all the same!</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">where</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mf">0.5</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">take</span><span class="o">(</span><span class="n">v</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">))</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">filterFoldLeft</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="o">)(</span><span class="mi">0</span><span class="n">d</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">d</span> <span class="o">}</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">shift</span> <span class="mi">1</span>
</pre></div>
</div>
<p>Try out some of the following for yourself:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">reversed</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="n">d</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">d</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">scanLeft</span><span class="o">(</span><span class="mi">0</span><span class="n">d</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">d</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">d</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">without</span> <span class="n">v</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">findOne</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">head</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">tail</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">(</span><span class="mi">0</span> <span class="o">-&gt;</span> <span class="mi">2</span><span class="o">).</span><span class="n">mask</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">concat</span> <span class="n">v</span>
</pre></div>
</div>
<p>Note that NA (missing values) are handled within most calculations. Saddle
tries to prevent accidentally using raw NA values; only two primitive types,
Float and Double, have NA values that are safe to use in raw form: their NA
representations are Float.NaN and Double.NaN, respectively.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">v</span> <span class="k">=</span> <span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">na</span><span class="o">.</span><span class="n">to</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">sum</span>

<span class="n">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">median</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="mf">1.5</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">prod</span>
<span class="n">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span> <span class="n">dropNA</span>                           <span class="c1">// becomes [1 2]</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">at</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>                            <span class="c1">// boxed to prevent shooting yourself in foot</span>
<span class="n">res4</span><span class="k">:</span> <span class="kt">org.saddle.scalar.Scalar</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="nc">NA</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">raw</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>                           <span class="c1">// you can do this, but be careful!</span>
<span class="n">res5</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2147483648</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">fillNA</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span><span class="o">)</span>                   <span class="c1">// becomes [1 1 2]; the argument is the index of the NA</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">d</span><span class="k">:</span> <span class="kt">Double</span> <span class="o">=</span> <span class="n">scalar</span><span class="o">.</span><span class="nc">Scalar</span><span class="o">(</span><span class="mf">1.0</span><span class="o">)</span> <span class="c1">// you can auto-unbox a double scalar</span>
</pre></div>
</div>
<p>Also, a Scalar[T] can convert to Option[T] implicitly, so you may do everything
with it that you may do with an Option; e.g., call map() or flatmap().</p>
<p>Finally, if you need to treat a Vec as a sequence, you may convert it to Seq,
(specifically, an IndexedSeq). Also, you may access (a copy of) Vec as an
array, by calling Vec.contents.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">toSeq</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">contents</span>
</pre></div>
</div>
</div>
<div class="section" id="series">
<h2>Series<a class="headerlink" href="#series" title="Permalink to this headline">¶</a></h2>
<p>A Series combines a Vec with an Index that provides an ordered key-value
mapping.  We&#8217;ll talk more about the details of Index later.  First, note a
Vec[T] can convert implicitly to a Series[Int, T]. So for instance:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Series</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">vec</span><span class="o">.</span><span class="n">rand</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</pre></div>
</div>
<p>The key type of a must have a natural ordering (ie, an Ordering of that type
within the implicit scope). However, the Series maintains the order in which
its data was supplied unless ordered othewise.</p>
<p>Let&#8217;s look at a few constructions:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>// we already know we can convert a Vec
scala&gt; Series(Vec(32, 12, 9))
res3: org.saddle.Series[Int,Int] =
[3 x 1]
0 -&gt; 32
1 -&gt; 12
2 -&gt; 9

// we can pass a pair of tuples
scala&gt; Series(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2, &quot;c&quot; -&gt; 3)
res4: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
a -&gt; 1
b -&gt; 2
c -&gt; 3

// any series of tuples will work, eg:
scala&gt; Series(List(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2, &quot;c&quot; -&gt; 3) : _*)

// can pass data and index separately:
scala&gt; Series(Vec(1,2,3), Index(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))

// you can create an empty Series like so:
scala&gt; Series.empty[String, Int]

// supplied order is maintained:
scala&gt; Series(Vec(1,2,3), Index(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;))
res11: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
c -&gt; 1
b -&gt; 2
a -&gt; 3

// unlike map, multiple keys are entirely fine:
scala&gt; Series(Vec(1,2,3,4), Index(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;))
res12: org.saddle.Series[java.lang.String,Int] =
[4 x 1]
c -&gt; 1
b -&gt; 2
a -&gt; 3
b -&gt; 4
</pre></div>
</div>
<p>With construction out of the way, let&#8217;s look at a few ways we can get data out
of a Series.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; val q = Series(Vec(1,3,2,4), Index(&quot;c&quot;, &quot;b&quot;, &quot;a&quot;, &quot;b&quot;))

// get the values or index
scala&gt; q.values
scala&gt; q.index

// extract value by numerical offset
scala&gt; q.at(2)
res20: org.saddle.scalar.Scalar[Int] = 3

scala&gt; q.at(2,3,1)
res0: org.saddle.Vec[Int] =
[3 x 1]
2
4
3

// or extract key
scala&gt; q.keyAt(2)
res21: org.saddle.scalar.Scalar[java.lang.String] = a

scala&gt; q.keyAt(2,3,1)
res24: org.saddle.Index[java.lang.String] =
[Index 3 x 1]
a
b
b

// sort by index ordering
scala&gt; q.sortedIx
res16: org.saddle.Series[java.lang.String,Int] =
[4 x 1]
a -&gt; 3
b -&gt; 2
b -&gt; 4
c -&gt; 1

// sort by value ordering
scala&gt; q.sorted
res17: org.saddle.Series[java.lang.String,Int] =
[4 x 1]
c -&gt; 1
b -&gt; 2
a -&gt; 3
b -&gt; 4

// extract elements matching the index
scala&gt; q(&quot;b&quot;)
res19: org.saddle.Series[java.lang.String,Int] =
[2 x 1]
b -&gt; 2
b -&gt; 4

scala&gt; q(&quot;a&quot;, &quot;b&quot;)
res1: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
a -&gt; 2
b -&gt; 3
b -&gt; 4

// notice ordering subtleties:
scala&gt; q(&quot;b&quot;, &quot;a&quot;)
res2: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
b -&gt; 3
b -&gt; 4
a -&gt; 2

// get first or last values
scala&gt; q.first
scala&gt; q.last

// or key
scala&gt; q.firstKey
scala&gt; q.lastKey

// &quot;reindex&quot; to a new index:
scala&gt; q.reindex(Index(&quot;a&quot;,&quot;c&quot;,&quot;d&quot;))
res4: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
a -&gt;  2
c -&gt;  1
d -&gt; NA

// or just by a sequence of keys:
scala&gt; q.reindex(&quot;a&quot;,&quot;c&quot;,&quot;d&quot;)

// notice that &#39;slicing&#39; ignores unknown keys:
scala&gt; q(&quot;a&quot;, &quot;d&quot;)
res5: org.saddle.Series[java.lang.String,Int] =
[1 x 1]
a -&gt; 2

// we cannot reindex with &quot;b&quot;, because it isn&#39;t unique.
// (the problem is, which &quot;b&quot; would we choose?)
scala&gt; q.reindex(&quot;a&quot;, &quot;b&quot;)
java.lang.IllegalArgumentException: requirement failed: Could not reindex unambiguously
...

// we can &quot;reset&quot; the index to integer labels
scala&gt; q.resetIndex

// or to a new index altogether
scala&gt; q.setIndex(Index(&quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;))

// to &#39;slice&#39;, we need a sorted index; slice is inclusive by default
scala&gt; val s = q.sortedIx
scala&gt; s.sliceBy(&quot;b&quot;, &quot;c&quot;)
res7: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
b -&gt; 3
b -&gt; 4
c -&gt; 1

// syntactic sugar is provided:
scala&gt; s.sliceBy(&quot;b&quot; -&gt; &quot;c&quot;)
scala&gt; s.sliceBy(* -&gt; &quot;b&quot;)

// where slice is by offset, exclusive by default, and the
// index doesn&#39;t have to be sorted:
scala&gt; q.slice(0,2)
res8: org.saddle.Series[java.lang.String,Int] =
[2 x 1]
c -&gt; 1
b -&gt; 3

// there are head/tail methods:
scala&gt; q.head(2)
scala&gt; q.tail(2)
</pre></div>
</div>
<p>Aside from extracting values, there are many fun ways to compute with Series.
Try the following:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">q</span> <span class="k">=</span> <span class="nc">Series</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">),</span> <span class="nc">Index</span><span class="o">(</span><span class="s">&quot;c&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">))</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">mapIndex</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="s">&quot;x&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">shift</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">filterIx</span><span class="o">(</span><span class="k">_</span> <span class="o">!=</span> <span class="s">&quot;b&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">filterAt</span> <span class="o">{</span> <span class="k">case</span> <span class="n">loc</span> <span class="k">=&gt;</span> <span class="n">loc</span> <span class="o">!=</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">loc</span> <span class="o">!=</span> <span class="mi">3</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">find</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">findKey</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">findOneKey</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">||</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">minKey</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">scanLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">acc</span><span class="o">,</span> <span class="n">v</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">v</span> <span class="o">}</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">reversed</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">m</span> <span class="k">=</span> <span class="n">q</span><span class="o">.</span><span class="n">mask</span><span class="o">(</span><span class="n">q</span><span class="o">.</span><span class="n">values</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">hasNA</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">dropNA</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">pad</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">rolling</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="k">_</span><span class="o">.</span><span class="n">minKey</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">splitAt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">sortedIx</span><span class="o">.</span><span class="n">splitBy</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>We can of course convert to a Vec or a Seq if we need to. The Series.toSeq
method yields a sequence of key/value tuples.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">toVec</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">q</span><span class="o">.</span><span class="n">toSeq</span>
</pre></div>
</div>
<p>We can also group by key in order to transform or combine the groupings, which
themselves are Series. For example:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; q.groupBy.combine(_.sum)
res19: org.saddle.Series[java.lang.String,Int] =
[3 x 1]
a -&gt; 2
b -&gt; 7
c -&gt; 1

scala&gt; q.groupBy.transform(s =&gt; s - s.mean)
res20: org.saddle.Series[java.lang.String,Double] =
[4 x 1]
c -&gt;  0.0000
b -&gt; -0.5000
a -&gt;  0.0000
b -&gt;  0.5000
</pre></div>
</div>
<p>You can also group by another index, or by a transformation of the current
index, by passing an argument into groupBy. See the Saddle API for more info.</p>
<p>The expressive nature of working with Series becomes apparent when you need to
align data:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; val a = Series(Vec(1,4,2,3), Index(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;))
scala&gt; val b = Series(Vec(5,2,1,8,7), Index(&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;,&quot;f&quot;))

scala&gt; a + b
res21: org.saddle.Series[java.lang.String,Int] =
[6 x 1]
a -&gt; NA
b -&gt;  9
c -&gt;  4
d -&gt;  4
e -&gt; NA
f -&gt; NA
</pre></div>
</div>
<p>You see that the indexes have been aligned prior to operation being performed.
Because there is a missing observation in each label of a, e, and f, the
summation is not done and instead an NA value is inserted into the result.</p>
<p>Generally, a full-outer join is performed. So, for instance:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; val a = Series(Vec(1,4,2), Index(&quot;a&quot;,&quot;b&quot;,&quot;b&quot;))
scala&gt; val b = Series(Vec(5,2,1), Index(&quot;b&quot;,&quot;b&quot;,&quot;d&quot;))

scala&gt; a + b
res22: org.saddle.Series[java.lang.String,Int] =
[6 x 1]
a -&gt; NA
b -&gt;  9
b -&gt;  6
b -&gt;  7
b -&gt;  4
d -&gt; NA
</pre></div>
</div>
<p>Most basic math and boolean operations are supported between two Series, as
well as between a Series and a scalar value.</p>
<p>We mentioned joins. Let&#8217;s look at a few join operations; the result is a Frame,
which we will touch on a bit later. These are similar in nature to SQL joins.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; val a = Series(Vec(1,4,2), Index(&quot;a&quot;,&quot;b&quot;,&quot;b&quot;))
scala&gt; val b = Series(Vec(5,2,1), Index(&quot;b&quot;,&quot;b&quot;,&quot;d&quot;))

scala&gt; a.join(b, how=index.LeftJoin)
res24: org.saddle.Frame[java.lang.String,Int,Int] =
[4 x 2]
      0  1
     -- --
a -&gt;  1 NA
b -&gt;  4  5
b -&gt;  4  2
b -&gt;  2  5
b -&gt;  2  2

scala&gt; a.join(b, how=index.RightJoin)
res25: org.saddle.Frame[java.lang.String,Int,Int] =
[4 x 2]
      0  1
     -- --
b -&gt;  4  5
b -&gt;  2  5
b -&gt;  4  2
b -&gt;  2  2
d -&gt; NA  1

scala&gt; a.join(b, how=index.InnerJoin)
res28: org.saddle.Frame[java.lang.String,Int,Int] =
[3 x 2]
      0  1
     -- --
b -&gt;  4  5
b -&gt;  4  2
b -&gt;  2  5
b -&gt;  2  2

scala&gt; a.join(b, how=index.OuterJoin)
res29: org.saddle.Frame[java.lang.String,Int,Int] =
[6 x 2]
      0  1
     -- --
a -&gt;  1 NA
b -&gt;  4  5
b -&gt;  4  2
b -&gt;  2  5
b -&gt;  2  2
d -&gt; NA  1
</pre></div>
</div>
<p>Finally, let&#8217;s take a look at a multiply indexed Series:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; val t = Series(Vec(1,2,3,4), Index((1,1),(1,2),(2,1),(2,2)))
t: org.saddle.Series[(Int, Int),Int] =
[4 x 1]
1 1 -&gt; 1
  2 -&gt; 2
2 1 -&gt; 3
  2 -&gt; 4
</pre></div>
</div>
<p>Sometimes you want to move the innermost row label to be a column label
instead. You can achieve this as follows:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; val f = t.pivot
f: org.saddle.Frame[Int,Int,Int] =
[2 x 2]
      1  2
     -- --
1 -&gt;  1  2
2 -&gt;  3  4
</pre></div>
</div>
<p>And this is how you get back the original Series:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; f.melt
res32: org.saddle.Series[(Int, Int),Int] =
[4 x 1]
1 1 -&gt; 1
  2 -&gt; 2
2 1 -&gt; 3
  2 -&gt; 4
</pre></div>
</div>
<p>This generalizes to tuples of higher order.</p>
</div>
<div class="section" id="mat">
<h2>Mat<a class="headerlink" href="#mat" title="Permalink to this headline">¶</a></h2>
<p>A Mat[T] represents a Matrix of values. Internally it is stored as a single
contiguous array; sometimes, a duplicate array is created which stores the same
values, but transposed, for speed of access having to do with memory locality.</p>
<p>This format was chosen to be compatible with DenseMatrix of <a class="reference external" href="http://code.google.com/p/efficient-java-matrix-library/">EJML</a>, a high
performance linear algebra library which provides the default matrix multiply
routine for Saddle. One or two properly placed implicit conversions can extend
Saddle to be a powerful linear algebra system.</p>
<p>Let&#8217;s start off with construction:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; Mat(2,2, Array(1,2,3,4))
res41: org.saddle.Mat[Int] =
[2 x 2]
1 2
3 4

// all same:
scala&gt; Mat(Array(1,3), Array(2,4))
scala&gt; Mat(Array(Array(1,3), Array(2,4)))
scala&gt; Mat(Vec(1,3), Vec(2,4))
scala&gt; Mat(Array(Vec(1,3), Vec(2,4)))

// identity matrix:
scala&gt; mat.ident(2)

// empty matrix:
scala&gt; Mat.empty[Double]

// zeros:
scala&gt; Mat[Int](2, 2)
</pre></div>
</div>
<p>Again, sometimes we want to create instances filled with random observations.
As to Vec, we can do the following:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">rand</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>       <span class="c1">// random doubles from within [-1.0, 1.0] excluding 0</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">randp</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>      <span class="c1">// random positive doubles</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">randn</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>      <span class="c1">// random normally distributed doubles</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">randn</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">12</span><span class="o">)</span> <span class="c1">// random normally distributed with mean=3, stdev=12</span>
</pre></div>
</div>
<p>There are a few other factory methods available:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">ones</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">zeros</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">mat</span><span class="o">.</span><span class="n">diag</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">))</span>
</pre></div>
</div>
<p>Let&#8217;s look at some basic operations with Mat. As with Vec, you may perform
calculations on two Mat instances, or on a Mat and a scalar value.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>// element-wise multiplication
scala&gt; Mat(2,2,Array(1,2,3,4)) * Mat(2,2,Array(4,1,2,3))
res55: org.saddle.Mat[Int] =
[2 x 2]
 4  2
 6 12

// matrix multiplication; note implicit conversion to Double
// instead of `dot`, can also use `mult`
scala&gt; Mat(2,2,Array(1,2,3,4)) dot Mat(2,2,Array(4,1,2,3))
res53: org.saddle.Mat[Double] =
[2 x 2]
 8.0000  7.0000
20.0000 15.0000


// matrix-vector multiplication
scala&gt; Mat(2,2,Array(1,2,3,4)) dot Vec(2,1)
res56: org.saddle.Mat[Double] =
[2 x 1]
 4.0000
10.0000

// as expected
scala&gt; Mat(2,2,Array(1,2,3,4)) * 2
scala&gt; Mat(2,2,Array(1,2,3,4)) + 2
scala&gt; Mat(2,2,Array(1,2,3,4)) &lt;&lt; 2
// etc...

// transpose
scala&gt; Mat(2,2,Array(1,2,3,4)).T
scala&gt; Mat(2,2,Array(1,2,3,4)).transposed

// properties of Mat
scala&gt; val m = Mat(2,2,Array(1,2,3,4))
scala&gt; m.numRows
scala&gt; m.numCols
scala&gt; m.isSquare
scala&gt; m.isEmpty
</pre></div>
</div>
<p>There are a few ways to extract values from a Mat.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; m.at(0,1)
res1: org.saddle.scalar.Scalar[Int] = 2

// be careful with this one!
scala&gt; m.raw(0,1)
res2: Int = 2

scala&gt; m.takeRows(0)
res0: org.saddle.Mat[Int] =
[1 x 2]
1 2

scala&gt; m.withoutRows(0)
res0: org.saddle.Mat[Int] =
[1 x 2]
3 4

scala&gt; m.takeCols(0)
res1: org.saddle.Mat[Int] =
[2 x 1]
1
3

scala&gt; m.col(0)
scala&gt; m.row(0)
scala&gt; m.rows()
scala&gt; m.cols()
</pre></div>
</div>
<p>Some other interesting methods on Mat:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; val m = Mat(2,2,Array(1,2,na.to[Int],4))
m: org.saddle.Mat[Int] =
[2 x 2]
 1  2
NA  4

scala&gt; m.rowsWithNA
res4: List[Int] = List(1)

scala&gt; m.dropRowsWithNA

scala&gt; m.reshape(1,4)
res6: org.saddle.Mat[Int] =
[1 x 4]
 1  2 NA  4

scala&gt; mat.rand(2,2).roundTo(2)
res8: org.saddle.Mat[Double] =
[2 x 2]
-0.3400  0.0000
-0.3800  0.2500
</pre></div>
</div>
<p>Finally, if you want to print, say, 100 rows and 10 columns:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">print</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="mi">10</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="frame">
<h2>Frame<a class="headerlink" href="#frame" title="Permalink to this headline">¶</a></h2>
<p>A Frame combines a Mat with a row index and a column index which provides a way
to index into the Mat. First, note a Mat[T] converts implicitly to a Frame[Int,
Int, T]. So for instance</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span><span class="k">:</span> <span class="kt">Frame</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">Int</span>, <span class="kt">Double</span><span class="o">]</span> <span class="k">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">rand</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span>
</pre></div>
</div>
<p>A Frame is represented internally as a sequence of column Vec instances all
sharing the same row index; additionally a transpose of the data is created
lazily if cross sections of data are requested.</p>
<p>Let&#8217;s look at some ways to instantiated a Frame:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; val v = Vec(1, 2)                              // given the following
scala&gt; val u = Vec(3, 4)
scala&gt; val s = Series(&quot;a&quot; -&gt; 1, &quot;b&quot; -&gt; 2)
scala&gt; val t = Series(&quot;b&quot; -&gt; 3, &quot;c&quot; -&gt; 4)

scala&gt; Frame(v, u)                                    // two-column frame

scala&gt; Frame(&quot;x&quot; -&gt; v, &quot;y&quot; -&gt; u)                      // with column index

scala&gt; Frame(s, t)                                    // aligned along rows
[3 x 2]
      0  1
     -- --
a -&gt;  1 NA
b -&gt;  2  3
c -&gt; NA  4

scala&gt; Frame(&quot;x&quot; -&gt; s, &quot;y&quot; -&gt; t)                      // with column index
[3 x 2]
      x  y
     -- --
a -&gt;  1 NA
b -&gt;  2  3
c -&gt; NA  4

scala&gt; Frame(Seq(s, t), Index(&quot;x&quot;, &quot;y&quot;))              // explicit column index

scala&gt; Frame(Seq(v, u), Index(0, 1), Index(&quot;x&quot;, &quot;y&quot;)) // row &amp; col indexes specified explicitly

scala&gt; Frame(Seq(v, u), Index(&quot;a&quot;, &quot;b&quot;))              // col index specified
</pre></div>
</div>
<p>You&#8217;ll notice that if an index is not provided, a default int index is set
where the index ranges between 0 and the length of the data.</p>
<p>Frame elements are all recognized as the same type by the compiler. But if you
want to work with frames whose columns contain heterogenous data, there are a
few facilities to make it easier. You can construct Frame[_, _, Any] using the
Panel() constructor, which mirrors the Frame() constructor, eg:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">p</span> <span class="k">=</span> <span class="nc">Panel</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">3</span><span class="o">),</span> <span class="nc">Vec</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span><span class="s">&quot;b&quot;</span><span class="o">,</span><span class="s">&quot;c&quot;</span><span class="o">))</span>
</pre></div>
</div>
<p>You may then extract columns of a particular type as follows:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">colType</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">p</span><span class="o">.</span><span class="n">colType</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">String</span><span class="o">]</span>
</pre></div>
</div>
<p>Speaking of types, if you want to generate an empty row or column of the right type:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">emptyRow</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">emptyCol</span>
</pre></div>
</div>
<p>Back to homogenous Frames. If you want to set or reset the index, these methods
are your friends:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="nc">Frame</span><span class="o">(</span><span class="s">&quot;x&quot;</span> <span class="o">-&gt;</span> <span class="n">s</span><span class="o">,</span> <span class="s">&quot;y&quot;</span> <span class="o">-&gt;</span> <span class="n">t</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">setRowIndex</span><span class="o">(</span><span class="nc">Index</span><span class="o">(</span><span class="mi">10</span><span class="o">,</span> <span class="mi">20</span><span class="o">))</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">setColIndex</span><span class="o">(</span><span class="nc">Index</span><span class="o">(</span><span class="s">&quot;p&quot;</span><span class="o">,</span> <span class="s">&quot;q&quot;</span><span class="o">))</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">resetRowIndex</span><span class="o">()</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">resetColIndex</span><span class="o">()</span>
</pre></div>
</div>
<p>(Note: frame <code class="docutils literal"><span class="pre">f</span></code> will carry through the next examples.)</p>
<p>You also have the following index transformation tools at hand:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">f</span><span class="o">.</span><span class="n">mapRowIndex</span> <span class="o">{</span> <span class="k">case</span> <span class="n">rx</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>
<span class="n">f</span><span class="o">.</span><span class="n">mapColIndex</span> <span class="o">{</span> <span class="k">case</span> <span class="n">cx</span> <span class="k">=&gt;</span> <span class="o">...</span> <span class="o">}</span>
</pre></div>
</div>
<p>Let&#8217;s next look at how to extract data from the Frame.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">rowAt</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>    <span class="c1">// extract row at offset 2, as Series</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">rowAt</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>  <span class="c1">// extract frame of rows 1 &amp; 2</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">rowAt</span><span class="o">(</span><span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="o">)</span> <span class="c1">// extract frame of rows 1 &amp; 2</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">colAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>    <span class="c1">// extract col at offset 1, as Series</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">colAt</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>  <span class="c1">// extract frame of cols 1 &amp; 2</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">colAt</span><span class="o">(</span><span class="mi">0</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">)</span> <span class="c1">// extract frame of cols 1 &amp; 2</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">rowAt</span></code> and <code class="docutils literal"><span class="pre">colAt</span></code> are used under the hood for the <code class="docutils literal"><span class="pre">at</span></code> extractor:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">at</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>              <span class="c1">// Scalar value</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">at</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">2</span><span class="o">),</span> <span class="mi">0</span><span class="o">)</span>    <span class="c1">// extract rows 1,2 of column 0</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">at</span><span class="o">(</span><span class="mi">0</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span>          <span class="c1">// extract rows 0,1 of column 1</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">at</span><span class="o">(</span><span class="mi">0</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">-&gt;</span><span class="mi">1</span><span class="o">)</span>       <span class="c1">// extract rows 0,1 of columns 0, 1</span>
<span class="c1">// etc...</span>
</pre></div>
</div>
<p>If you want more control over slicing, you can use these methods:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">colSlice</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>        <span class="c1">// frame slice consisting of column 0</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">rowSlice</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">2</span><span class="o">)</span>      <span class="c1">// row slice from 0 until 3, striding by 2</span>
</pre></div>
</div>
<p>Of course, this is an bi-indexed data structure, so we can use its indexes to
select out data using keys:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">row</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">)</span>             <span class="c1">// row series &#39;a&#39;, with all columns</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">col</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)</span>             <span class="c1">// col series &#39;x&#39;, with all rows</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">row</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">)</span>        <span class="c1">// select two rows</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">row</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">-&gt;</span><span class="s">&quot;b&quot;</span><span class="o">)</span>        <span class="c1">// slice two rows (index must be sorted)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">row</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">))</span>   <span class="c1">// another way to select</span>
</pre></div>
</div>
<p>A more explict way to slice with keys is as follows, and you can specify
whether the right bound is inclusive or exclusive. Again, to slice, the index
keys must be ordered.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">rowSliceBy</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="n">inclusive</span><span class="k">=</span><span class="kc">false</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">colSliceBy</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">,</span> <span class="s">&quot;x&quot;</span><span class="o">,</span> <span class="n">inclusive</span><span class="k">=</span><span class="kc">true</span><span class="o">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal"><span class="pre">row</span></code> and <code class="docutils literal"><span class="pre">col</span></code> methods are used under the hood for the <code class="docutils literal"><span class="pre">apply</span></code> method:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;x&quot;</span><span class="o">)</span>             <span class="c1">// extract a one-element frame by keys</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">-&gt;</span><span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;x&quot;</span><span class="o">)</span>        <span class="c1">// two-row, one-column frame</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">),</span> <span class="s">&quot;x&quot;</span><span class="o">)</span>   <span class="c1">// same as above, but extracting, not slicing</span>
</pre></div>
</div>
<p>The methods of extracting multiple rows shown above can of course be done on
columns as well.</p>
<p>You can also split up the Frame by key or index:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">colSplitAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>          <span class="c1">// split into two frames at column 1</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">colSplitBy</span><span class="o">(</span><span class="s">&quot;y&quot;</span><span class="o">)</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">rowSplitAt</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">rowSplitBy</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>You extract some number of rows or columns:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">head</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>                <span class="c1">// operates on rows</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">tail</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">headCol</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>             <span class="c1">// operates on cols</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">tailCol</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
</pre></div>
</div>
<p>Or the first &amp; last of some key (which is helpful when you&#8217;ve got a multi-key
index):</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">first</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)</span>              <span class="c1">// first row indexed by &quot;b&quot; key</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">last</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)</span>               <span class="c1">// last row indexed by &quot;b&quot; key</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">firstCol</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">lastCol</span><span class="o">(</span><span class="s">&quot;x&quot;</span><span class="o">)</span>
</pre></div>
</div>
<p>There are a few other methods of extracting data:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">filter</span> <span class="o">{</span> <span class="k">case</span> <span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">mean</span> <span class="o">&gt;</span> <span class="mf">2.0</span> <span class="o">}</span>  <span class="c1">// any column whose series satisfies predicate</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">filterIx</span> <span class="o">{</span> <span class="k">case</span> <span class="n">x</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">==</span> <span class="s">&quot;x&quot;</span> <span class="o">}</span>    <span class="c1">// col where index matches key &quot;x&quot;</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">where</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>            <span class="c1">// extract second column</span>
</pre></div>
</div>
<p>There are analogous methods to operate on rows rather then columns:</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">rfilter</span></code></li>
<li><code class="docutils literal"><span class="pre">rfilterIx</span></code></li>
<li><code class="docutils literal"><span class="pre">rwhere</span></code></li>
</ul>
<p>etc... in general, methods operate on a column-wise basis, whereas the
<code class="docutils literal"><span class="pre">r</span></code>-counterpart does so on a row-wise basis.</p>
<p>You can drop cols (rows) containing <em>any</em> NA values:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">dropNA</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">rdropNA</span>
</pre></div>
</div>
<p>Let&#8217;s take a look at some operations we can do with Frames. We can do all the
normal binary math operations with Frames, with either a scalar value or with
another Frame. When two frames are involved, they are reindexed along both axes
to match the outer join of their indices, but any missing observation in either
will carry through the calculations.</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">+</span> <span class="mi">1</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">*</span> <span class="n">f</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="nc">Frame</span><span class="o">(</span><span class="s">&quot;y&quot;</span><span class="o">-&gt;</span><span class="nc">Series</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">-&gt;</span><span class="mi">5</span><span class="o">,</span> <span class="s">&quot;d&quot;</span><span class="o">-&gt;</span><span class="mi">10</span><span class="o">))</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">+</span> <span class="n">g</span>                      <span class="c1">// one non-NA entry, (&quot;b&quot;, &quot;y&quot;, 8)</span>
</pre></div>
</div>
<p>You can effectively supply your own binary frame operation using joinMap, which
lets you control the join style on rows and columns:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">joinMap</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">rhow</span><span class="k">=</span><span class="n">index</span><span class="o">.</span><span class="nc">LeftJoin</span><span class="o">,</span> <span class="n">chow</span><span class="k">=</span><span class="n">index</span><span class="o">.</span><span class="nc">LeftJoin</span><span class="o">)</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">}</span>
</pre></div>
</div>
<p>If you want simply to align one frame to another without performing an operation,
use the following method:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="o">(</span><span class="n">fNew</span><span class="o">,</span> <span class="n">gNew</span><span class="o">)</span> <span class="k">=</span> <span class="n">f</span><span class="o">.</span><span class="n">align</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">rhow</span><span class="k">=</span><span class="n">index</span><span class="o">.</span><span class="nc">LeftJoin</span><span class="o">,</span> <span class="n">chow</span><span class="k">=</span><span class="n">index</span><span class="o">.</span><span class="nc">OuterJoin</span><span class="o">)</span>
</pre></div>
</div>
<p>If you want to treat a Frame as a matrix to use in linear algebraic fashion,
call the <code class="docutils literal"><span class="pre">toMat</span></code> method.</p>
<p>We can sort a frame in various ways:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">sortedRIx</span>                <span class="c1">// sorted by row index</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">sortedCIx</span>                <span class="c1">// sorted by col index</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">sortedRows</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span><span class="mi">1</span><span class="o">)</span>          <span class="c1">// sort rows by (primary) col 0 and (secondary) col 1</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">sortedCols</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">0</span><span class="o">)</span>          <span class="c1">// sort cols by (primary) row 1 and (secondary) row 0</span>
</pre></div>
</div>
<p>We can also sort by an ordering provided by the result of a function acting on
rows or cols:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">sortedRowsBy</span> <span class="o">{</span> <span class="k">case</span> <span class="n">r</span> <span class="k">=&gt;</span> <span class="n">r</span><span class="o">.</span><span class="n">at</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">}</span>   <span class="c1">// sort rows by first element of row</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">sortedColsBy</span> <span class="o">{</span> <span class="k">case</span> <span class="n">c</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">at</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">}</span>   <span class="c1">// sort cols by first element of col</span>
</pre></div>
</div>
<p>There are several mapping functions:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">mapValues</span> <span class="o">{</span> <span class="k">case</span> <span class="n">t</span> <span class="k">=&gt;</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">}</span>        <span class="c1">// add one to each element of frame</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">mapVec</span> <span class="o">{</span> <span class="k">case</span> <span class="n">v</span> <span class="k">=&gt;</span> <span class="n">v</span><span class="o">.</span><span class="n">demeaned</span> <span class="o">}</span>      <span class="c1">// map over each col vec of the frame</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">reduce</span> <span class="o">{</span> <span class="k">case</span> <span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">mean</span> <span class="o">}</span>          <span class="c1">// collapse each col series to a single value</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">transform</span> <span class="o">{</span> <span class="k">case</span> <span class="n">s</span> <span class="k">=&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">reversed</span> <span class="o">}</span>   <span class="c1">// transform each series; outerjoin results</span>
</pre></div>
</div>
<p>We can mask out values:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">mask</span><span class="o">(</span><span class="k">_</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">)</span>                          <span class="c1">// mask out values &gt; 2</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">mask</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">true</span><span class="o">))</span>         <span class="c1">// mask out rows 1 &amp; 2 (keep row 0)</span>
</pre></div>
</div>
<p>Columns (rows) containing <em>only</em> NA values can be dropped as follows:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">mask</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">,</span> <span class="kc">false</span><span class="o">)).</span><span class="n">rsqueeze</span>   <span class="c1">// drop rows containing NA values</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">rmask</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="kc">true</span><span class="o">)).</span><span class="n">squeeze</span>          <span class="c1">// takes &quot;x&quot; column</span>
</pre></div>
</div>
<p>We can groupBy in order to combine or transform:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="s">&quot;a&quot;</span><span class="o">).</span><span class="n">combine</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">count</span><span class="o">)</span>       <span class="c1">// # obs in each column that have/not row key &quot;a&quot;</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="k">_</span> <span class="o">==</span> <span class="s">&quot;a&quot;</span><span class="o">).</span><span class="n">transform</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">demeaned</span><span class="o">)</span>  <span class="c1">// contrived, but you get the idea hopefully!</span>
</pre></div>
</div>
<p>We can join against another frame, or against a series:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">how</span><span class="k">=</span><span class="n">index</span><span class="o">.</span><span class="nc">LeftJoin</span><span class="o">)</span>              <span class="c1">// left joins on row index, drops col indexes</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">join</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">how</span><span class="k">=</span><span class="n">index</span><span class="o">.</span><span class="nc">LeftJoin</span><span class="o">)</span>              <span class="c1">// implicitly promotes s to Frame</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">joinS</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="n">how</span><span class="k">=</span><span class="n">index</span><span class="o">.</span><span class="nc">LeftJoin</span><span class="o">)</span>             <span class="c1">// use Series directly</span>
</pre></div>
</div>
<p>Btw, to join a Frame to a series, the call looks like this:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">s</span><span class="o">.</span><span class="n">joinF</span><span class="o">(</span><span class="n">g</span><span class="o">,</span> <span class="n">how</span><span class="k">=</span><span class="n">index</span><span class="o">.</span><span class="nc">LeftJoin</span><span class="o">)</span>
</pre></div>
</div>
<p>Of course, if you want to join along the column index instead, there is a
<code class="docutils literal"><span class="pre">rjoin</span></code> method.</p>
<p>Let&#8217;s look at a few data reshaping commands. Try the following:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">melt</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">melt</span><span class="o">.</span><span class="n">mapRowIndex</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">b</span><span class="o">,</span> <span class="n">a</span><span class="o">)</span> <span class="o">}</span> <span class="n">colAt</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="n">pivot</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">mapColIndex</span> <span class="o">{</span> <span class="k">case</span> <span class="n">c</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">c</span><span class="o">)</span> <span class="o">}</span> <span class="n">stack</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">f</span><span class="o">.</span><span class="n">mapRowIndex</span> <span class="o">{</span> <span class="k">case</span> <span class="n">r</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="o">}</span> <span class="n">unstack</span>
</pre></div>
</div>
<p>There are statistics available on Frames on a column-wise basis that are
NA-aware. They are provided via an implicit conversion to <code class="docutils literal"><span class="pre">FrameStats</span></code>; look
there to see what&#8217;s available.</p>
<p>Finally, note that <code class="docutils literal"><span class="pre">toSeq</span></code> converts a Frame to a sequence of (row, col,
value) triples.</p>
</div>
<div class="section" id="index">
<h2>Index<a class="headerlink" href="#index" title="Permalink to this headline">¶</a></h2>
<p>Index provides constant-time lookup of a value within array-backed storage, and
support for joining and slice operations. There are a few factory methods for
creating an Index:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Index</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">)</span>           <span class="c1">// from seq of values</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Index</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">))</span>      <span class="c1">// from vec</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Index</span><span class="o">(</span><span class="nc">Array</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">))</span>    <span class="c1">// from array</span>
</pre></div>
</div>
<p>To create a multi-level index, you may do the following. In this example, the
Index is comprised of (1,a), (2,b), and (3,c):</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">Index</span><span class="o">.</span><span class="n">make</span><span class="o">(</span><span class="nc">Vec</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">),</span> <span class="nc">Vec</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">))</span>
</pre></div>
</div>
<p>You likely do not want to utilize the methods of Index directly very often, but
rather attach them to data (in Series and Frames) to achieve your goals in a
more indirect manner. Still, there are a few useful tools:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span> <span class="k">=</span> <span class="nc">Index</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;a&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;b&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">,</span> <span class="s">&quot;c&quot;</span><span class="o">)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span><span class="o">.</span><span class="n">next</span><span class="o">(</span><span class="s">&quot;a&quot;</span><span class="o">)</span>                                <span class="c1">// returns &quot;b&quot;</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">x</span><span class="o">.</span><span class="n">prev</span><span class="o">(</span><span class="s">&quot;b&quot;</span><span class="o">)</span>                                <span class="c1">// returns &quot;a&quot;</span>
</pre></div>
</div>
<p>For next and prev to work, the Index must be contiguous in values, although
sortedness is unnecessary. By contiguous, we mean a-b-a-b would not be a valid
ordering of data, but a-a-b-b would be.</p>
<p>For Index instances with Set semantics (ie, no duplicate keys), you have
fast <code class="docutils literal"><span class="pre">union</span></code> and <code class="docutils literal"><span class="pre">intersect</span></code> methods.</p>
<p>For map-like functionality, there is <code class="docutils literal"><span class="pre">contains</span></code> and <code class="docutils literal"><span class="pre">exists</span></code>, although
since Index is really a multi-map, the <code class="docutils literal"><span class="pre">get</span></code> function returns an array of
locations within the backing array, and <code class="docutils literal"><span class="pre">count</span></code> gives you how many entries
exist for a particular key. <code class="docutils literal"><span class="pre">uniques</span></code> allows you to get all the unique keys,
and the methods <code class="docutils literal"><span class="pre">getFirst</span></code> and <code class="docutils literal"><span class="pre">getLast</span></code> retrieve the location offsets of a
particular key. The API is worth exploring further.</p>
</div>
<div class="section" id="dates-times-and-recurrences">
<h2>Dates/Times and Recurrences<a class="headerlink" href="#dates-times-and-recurrences" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">org.saddle.time._</span></code> module provides a useful factory method for joda
DateTime objects: <code class="docutils literal"><span class="pre">datetime</span></code>. It provides vector manipulations on Vec and
Index instances of type <code class="docutils literal"><span class="pre">DateTime</span></code> (via the implicit <code class="docutils literal"><span class="pre">TimeAccessors</span></code>).</p>
<p>As of Saddle 1.3, the library provides an implementation of recurrence rules
(<code class="docutils literal"><span class="pre">RRule</span></code>), with a few default instances which may be found in the module
<code class="docutils literal"><span class="pre">RRules</span></code>. To illustrate, the following code generates dates at business month
ends for the first four months of 2013:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; import RRules._
import RRules._

scala&gt; Index.make(bizEoms, datetime(2013,1,1), datetime(2013,5,1))
res0: org.saddle.Index[org.joda.time.DateTime] =
[Index 4 x 1]
2013-01-31 00:00:00.000-05:00
2013-02-28 00:00:00.000-05:00
2013-03-29 00:00:00.000-04:00
2013-04-30 00:00:00.000-04:00
</pre></div>
</div>
<p>An <code class="docutils literal"><span class="pre">RRule</span></code> object allows for complex recurrence rule generation following the
RFC 2445 standard. (The implementation utilizes google-rfc-2445 under the hood,
licensed under Apache 2.0.) <code class="docutils literal"><span class="pre">RRule</span></code>&#8216;s can be combined with the <code class="docutils literal"><span class="pre">Index.make</span></code>
factory method to instantiate indexes as above, or can be used independently to
do complex date/time math.  For example, the <code class="docutils literal"><span class="pre">counting</span></code> method of <code class="docutils literal"><span class="pre">RRule</span></code>
provides syntactic sugar to do date offset calculation:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; RRule(MONTHLY) withInterval(2) counting 5 from datetime(2013,1,1)
res1: org.joda.time.DateTime = 2013-09-01T00:00:00.000-04:00
</pre></div>
</div>
<p>You may also generate iterators of <code class="docutils literal"><span class="pre">DateTime</span></code>&#8216;s using <code class="docutils literal"><span class="pre">RRule</span></code> (here we take
the first five generated values and convert to a list):</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; weeklyOn(FR) withInterval(2) from datetime(2013,1,1) take 5 toList
res2: List[org.joda.time.DateTime] = List(2013-01-04T00:00:00.000-05:00,
2013-01-18T00:00:00.000-05:00, 2013-02-01T00:00:00.000-05:00,
2013-02-15T00:00:00.000-05:00, 2013-03-01T00:00:00.000-05:00)
</pre></div>
</div>
<p>You may conform a datetime instance forward or backward using the <code class="docutils literal"><span class="pre">conform</span></code>
method:</p>
<div class="code bash highlight-scala"><div class="highlight"><pre>scala&gt; conform(weeklyOn(FR), datetime(2013,1,1), forward=false)
res10: org.joda.time.DateTime = 2012-12-28T00:00:00.000-05:00
</pre></div>
</div>
</div>
<div class="section" id="i-o">
<h2>I/O<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal"><span class="pre">org.saddle.io._</span></code> module provides some basic, and not-so-basic, I/O
functionality, although there is still much to be developed. There is a fast
csv file reader.</p>
<p>There is also HDF5 reading/writing available for Series and Frame objects that
is essentially compatible with the basic pandas format (as of pandas 0.9), but
note that it only supports certain primitive types like Int/Long/Double, and
DateTime &amp; String objects, but not all Serializable Java classes.</p>
<p>Please note that to use HDF5, you must include the dependency on saddle-hdf5,
and have installed native HDF5 library from the HDF5 <a class="reference external" href="http://www.hdfgroup.org/hdf-java-html/">binaries</a> so that the
native shared library <code class="docutils literal"><span class="pre">libjhdf5</span></code> is locatable in the java library path; you
can check via:</p>
<div class="code scala highlight-scala"><div class="highlight"><pre><span class="n">println</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="n">getProperty</span><span class="o">(</span><span class="s">&quot;java.library.path&quot;</span><span class="o">))</span>
</pre></div>
</div>
</div>
<div class="section" id="hello-campaign-contributions">
<h2>Hello, Campaign Contributions<a class="headerlink" href="#hello-campaign-contributions" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s take a quick look at processing some real data with the latest snapshot
version of Saddle. We&#8217;ll use data found at the <a class="reference external" href="http://www.fec.gov/disclosurep/PDownload.do">FEC</a>, the Federal Election
Commission.  Download a file... the <a class="reference external" href="ftp://ftp.fec.gov/FEC/Presidential_Map/2012/P00000001/P00000001-ALL.zip">ALL.zip</a> file is fairly chunky at about 1Gb
of unzipped text data, but let&#8217;s go for it! Unzip to a directory, and launch an
SBT session with sufficient memory (eg, <code class="docutils literal"><span class="pre">sbt</span> <span class="pre">-mem</span> <span class="pre">4096</span></code>).</p>
<div class="code scala highlight-scala"><div class="highlight"><pre><span class="k">import</span> <span class="nn">org.saddle.io._</span>

<span class="c1">// create reference to CSV file</span>
<span class="k">val</span> <span class="n">file</span> <span class="k">=</span> <span class="nc">CsvFile</span><span class="o">(</span><span class="s">&quot;P00000001-ALL.csv&quot;</span><span class="o">)</span>

<span class="c1">// parse columns 2 and 9 of the CSV and convert the result to a Frame</span>
<span class="c1">// (we know in advance these cols are candidate name and donation amount)</span>
<span class="c1">// &amp; set the first row as the col index</span>
<span class="c1">// &amp; the first col (candidate names) as the row index</span>
<span class="k">val</span> <span class="n">frame</span> <span class="k">=</span> <span class="nc">CsvParser</span><span class="o">.</span><span class="n">parse</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span><span class="mi">9</span><span class="o">))(</span><span class="n">file</span><span class="o">).</span><span class="n">withRowIndex</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">withColIndex</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>

<span class="c1">// convert frame body data to long primitives, mapping any parse errors to NA</span>
<span class="k">val</span> <span class="n">data</span> <span class="k">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">mapValues</span><span class="o">(</span><span class="nc">CsvParser</span><span class="o">.</span><span class="n">parseLong</span><span class="o">)</span>

<span class="c1">// look at the total contributions by candidate name, descending</span>
<span class="n">data</span><span class="o">.</span><span class="n">groupBy</span><span class="o">.</span><span class="n">combine</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">sum</span><span class="o">).</span><span class="n">sortedRowsBy</span> <span class="o">{</span> <span class="k">case</span> <span class="n">r</span> <span class="k">=&gt;</span> <span class="o">-</span><span class="n">r</span><span class="o">.</span><span class="n">raw</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span> <span class="o">}</span> <span class="n">print</span><span class="o">(</span><span class="mi">14</span><span class="o">)</span>
</pre></div>
</div>
<p>For fun, try looking at the mean and standard deviation of the campaign
contribution of each candidate.</p>
</div>
<div class="section" id="utilities">
<h2>Utilities<a class="headerlink" href="#utilities" title="Permalink to this headline">¶</a></h2>
<p>There some neat helper functions in the <code class="docutils literal"><span class="pre">org.saddle.array._</span></code> module to work
with arrays of primitives:</p>
<ul class="simple">
<li>range</li>
<li>shuffle</li>
<li>tile</li>
<li>random array generators</li>
<li>linspace</li>
<li>filter</li>
<li>flatten</li>
<li>argsort</li>
<li>argmin, argmax</li>
</ul>
<p>The <code class="docutils literal"><span class="pre">org.saddle.util.Random</span></code> class provides a xorshift Marsiglia primitive
value pseudorandom number generator the underlies the random number generation
throughout Saddle.</p>
</div>
<div class="section" id="a-note-on-optimization">
<h2>A note on optimization<a class="headerlink" href="#a-note-on-optimization" title="Permalink to this headline">¶</a></h2>
<p>The data structures above attempt to operate on primitives whenever possible,
although the specialization is not to every primitive JVM data type as of yet.
For example, <code class="docutils literal"><span class="pre">Vec</span></code> is specialized on Boolean, Int, Long, and Double; but not
yet Float, yet, so Vec[Float] operations will (un)box.</p>
<p>Try to avoid looping through these structures; they were meant for terse lines
of code which operate in a vectorized manner. If you find yourself looping
through them, you&#8217;re probably doing it wrong!</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebarwrapper">
      <div class="sphinxsidebar">
  <div class="logo">
    <a href="index.html">
      <img class="logo" src="_static/logo.png" width=200 alt="Logo"/>
    </a>
  </div>
  <ul>
<li><a class="reference internal" href="#">Quick Start Guide</a><ul>
<li><a class="reference internal" href="#intro">Intro</a></li>
<li><a class="reference internal" href="#vec">Vec</a></li>
<li><a class="reference internal" href="#series">Series</a></li>
<li><a class="reference internal" href="#mat">Mat</a></li>
<li><a class="reference internal" href="#frame">Frame</a></li>
<li><a class="reference internal" href="#index">Index</a></li>
<li><a class="reference internal" href="#dates-times-and-recurrences">Dates/Times and Recurrences</a></li>
<li><a class="reference internal" href="#i-o">I/O</a></li>
<li><a class="reference internal" href="#hello-campaign-contributions">Hello, Campaign Contributions</a></li>
<li><a class="reference internal" href="#utilities">Utilities</a></li>
<li><a class="reference internal" href="#a-note-on-optimization">A note on optimization</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="whatsnew.html"
                        title="previous chapter">What&#8217;s New</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="guide.html"
                        title="next chapter">User Guide</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2013, The Saddle Development Team.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>